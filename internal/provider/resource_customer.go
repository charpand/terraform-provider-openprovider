// Package provider implements the Terraform provider for OpenProvider.
package provider

import (
	"context"
	"fmt"

	"github.com/charpand/terraform-provider-openprovider/internal/client"
	"github.com/charpand/terraform-provider-openprovider/internal/client/customers"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource                = &CustomerResource{}
	_ resource.ResourceWithConfigure   = &CustomerResource{}
	_ resource.ResourceWithImportState = &CustomerResource{}
)

// CustomerResource is the resource implementation.
type CustomerResource struct {
	client *client.Client
}

// NewCustomerResource returns a new instance of the customer resource.
func NewCustomerResource() resource.Resource {
	return &CustomerResource{}
}

// Metadata returns the resource type name.
func (r *CustomerResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_customer"
}

// Schema defines the schema for the resource.
func (r *CustomerResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages an OpenProvider customer (contact handle).",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The customer identifier (same as handle).",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"handle": schema.StringAttribute{
				MarkdownDescription: "The customer handle (e.g., XX123456-XX). This is auto-generated by Openprovider upon creation.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"company_name": schema.StringAttribute{
				MarkdownDescription: "The company name (optional).",
				Optional:            true,
			},
			"email": schema.StringAttribute{
				MarkdownDescription: "The customer's email address.",
				Required:            true,
			},
			"locale": schema.StringAttribute{
				MarkdownDescription: "The customer's language/locale (e.g., en_US).",
				Optional:            true,
			},
			"comments": schema.StringAttribute{
				MarkdownDescription: "Custom notes about this customer.",
				Optional:            true,
			},
		},
		Blocks: map[string]schema.Block{
			"phone": schema.SingleNestedBlock{
				MarkdownDescription: "The customer's phone number.",
				Attributes: map[string]schema.Attribute{
					"country_code": schema.StringAttribute{
						MarkdownDescription: "Country code (e.g., 1 for US).",
						Required:            true,
					},
					"area_code": schema.StringAttribute{
						MarkdownDescription: "Area code.",
						Required:            true,
					},
					"number": schema.StringAttribute{
						MarkdownDescription: "Phone number.",
						Required:            true,
					},
				},
			},
			"address": schema.SingleNestedBlock{
				MarkdownDescription: "The customer's address.",
				Attributes: map[string]schema.Attribute{
					"street": schema.StringAttribute{
						MarkdownDescription: "Street name.",
						Required:            true,
					},
					"number": schema.StringAttribute{
						MarkdownDescription: "Street number.",
						Optional:            true,
					},
					"suffix": schema.StringAttribute{
						MarkdownDescription: "Address suffix (e.g., apartment number).",
						Optional:            true,
					},
					"city": schema.StringAttribute{
						MarkdownDescription: "City name.",
						Required:            true,
					},
					"state": schema.StringAttribute{
						MarkdownDescription: "State or province.",
						Optional:            true,
					},
					"zipcode": schema.StringAttribute{
						MarkdownDescription: "Postal/ZIP code.",
						Optional:            true,
					},
					"country": schema.StringAttribute{
						MarkdownDescription: "Country code (e.g., US, NL).",
						Required:            true,
					},
				},
			},
			"name": schema.SingleNestedBlock{
				MarkdownDescription: "The customer's name.",
				Attributes: map[string]schema.Attribute{
					"first_name": schema.StringAttribute{
						MarkdownDescription: "First name.",
						Required:            true,
					},
					"last_name": schema.StringAttribute{
						MarkdownDescription: "Last name.",
						Required:            true,
					},
					"initials": schema.StringAttribute{
						MarkdownDescription: "Initials.",
						Optional:            true,
					},
					"prefix": schema.StringAttribute{
						MarkdownDescription: "Name prefix (e.g., Mr., Dr.).",
						Optional:            true,
					},
				},
			},
		},
	}
}

// Configure adds the provider configured client to the resource.
func (r *CustomerResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = client
}

// Create creates the resource and sets the initial Terraform state.
func (r *CustomerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan CustomerModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate required nested blocks
	if plan.Phone == nil {
		resp.Diagnostics.AddError(
			"Missing Required Block",
			"The phone block is required for creating a customer.",
		)
	}
	if plan.Address == nil {
		resp.Diagnostics.AddError(
			"Missing Required Block",
			"The address block is required for creating a customer.",
		)
	}
	if plan.Name == nil {
		resp.Diagnostics.AddError(
			"Missing Required Block",
			"The name block is required for creating a customer.",
		)
	}
	if resp.Diagnostics.HasError() {
		return
	}

	// Create customer request
	createReq := &customers.CreateCustomerRequest{
		Email: plan.Email.ValueString(),
		Phone: customers.Phone{
			CountryCode: plan.Phone.CountryCode.ValueString(),
			AreaCode:    plan.Phone.AreaCode.ValueString(),
			Number:      plan.Phone.Number.ValueString(),
		},
		Address: customers.Address{
			Street:  plan.Address.Street.ValueString(),
			City:    plan.Address.City.ValueString(),
			Country: plan.Address.Country.ValueString(),
		},
		Name: customers.Name{
			FirstName: plan.Name.FirstName.ValueString(),
			LastName:  plan.Name.LastName.ValueString(),
		},
	}

	if !plan.CompanyName.IsNull() {
		createReq.CompanyName = plan.CompanyName.ValueString()
	}
	if !plan.Locale.IsNull() {
		createReq.Locale = plan.Locale.ValueString()
	}
	if !plan.Comments.IsNull() {
		createReq.Comments = plan.Comments.ValueString()
	}

	// Set optional address fields
	if !plan.Address.Number.IsNull() {
		createReq.Address.Number = plan.Address.Number.ValueString()
	}
	if !plan.Address.Suffix.IsNull() {
		createReq.Address.Suffix = plan.Address.Suffix.ValueString()
	}
	if !plan.Address.State.IsNull() {
		createReq.Address.State = plan.Address.State.ValueString()
	}
	if !plan.Address.Zipcode.IsNull() {
		createReq.Address.Zipcode = plan.Address.Zipcode.ValueString()
	}

	// Set optional name fields
	if !plan.Name.Initials.IsNull() {
		createReq.Name.Initials = plan.Name.Initials.ValueString()
	}
	if !plan.Name.Prefix.IsNull() {
		createReq.Name.Prefix = plan.Name.Prefix.ValueString()
	}

	// Create the customer
	handle, err := customers.Create(r.client, createReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Creating Customer",
			fmt.Sprintf("Could not create customer: %s", err.Error()),
		)
		return
	}

	// Set computed values
	plan.Handle = types.StringValue(handle)
	plan.ID = types.StringValue(handle)

	// Save state
	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

// Read refreshes the Terraform state with the latest data.
func (r *CustomerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state CustomerModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	handle := state.Handle.ValueString()

	// Get customer
	customer, err := customers.Get(r.client, handle)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Reading Customer",
			fmt.Sprintf("Could not read customer %s: %s", handle, err.Error()),
		)
		return
	}

	if customer == nil {
		// Customer not found - remove from state
		resp.State.RemoveResource(ctx)
		return
	}

	// Map to state
	state = *mapCustomerToModel(customer)

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *CustomerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan CustomerModel
	var state CustomerModel

	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	diags = req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	handle := state.Handle.ValueString()

	// Create update request
	updateReq := &customers.UpdateCustomerRequest{}

	// Update email if changed
	if !plan.Email.Equal(state.Email) {
		updateReq.Email = plan.Email.ValueString()
	}

	// Update optional fields if changed
	if !plan.CompanyName.Equal(state.CompanyName) && !plan.CompanyName.IsNull() {
		updateReq.CompanyName = plan.CompanyName.ValueString()
	}
	if !plan.Locale.Equal(state.Locale) && !plan.Locale.IsNull() {
		updateReq.Locale = plan.Locale.ValueString()
	}
	if !plan.Comments.Equal(state.Comments) && !plan.Comments.IsNull() {
		updateReq.Comments = plan.Comments.ValueString()
	}

	// Update phone if changed
	if plan.Phone != nil && state.Phone != nil {
		if !plan.Phone.CountryCode.Equal(state.Phone.CountryCode) ||
			!plan.Phone.AreaCode.Equal(state.Phone.AreaCode) ||
			!plan.Phone.Number.Equal(state.Phone.Number) {
			updateReq.Phone = &customers.Phone{
				CountryCode: plan.Phone.CountryCode.ValueString(),
				AreaCode:    plan.Phone.AreaCode.ValueString(),
				Number:      plan.Phone.Number.ValueString(),
			}
		}
	}

	// Update address if changed
	if plan.Address != nil && state.Address != nil {
		addressChanged := !plan.Address.Street.Equal(state.Address.Street) ||
			!plan.Address.City.Equal(state.Address.City) ||
			!plan.Address.Country.Equal(state.Address.Country) ||
			!plan.Address.Number.Equal(state.Address.Number) ||
			!plan.Address.Suffix.Equal(state.Address.Suffix) ||
			!plan.Address.State.Equal(state.Address.State) ||
			!plan.Address.Zipcode.Equal(state.Address.Zipcode)

		if addressChanged {
			updateReq.Address = &customers.Address{
				Street:  plan.Address.Street.ValueString(),
				City:    plan.Address.City.ValueString(),
				Country: plan.Address.Country.ValueString(),
			}
			if !plan.Address.Number.IsNull() {
				updateReq.Address.Number = plan.Address.Number.ValueString()
			}
			if !plan.Address.Suffix.IsNull() {
				updateReq.Address.Suffix = plan.Address.Suffix.ValueString()
			}
			if !plan.Address.State.IsNull() {
				updateReq.Address.State = plan.Address.State.ValueString()
			}
			if !plan.Address.Zipcode.IsNull() {
				updateReq.Address.Zipcode = plan.Address.Zipcode.ValueString()
			}
		}
	}

	// Update name if changed
	if plan.Name != nil && state.Name != nil {
		nameChanged := !plan.Name.FirstName.Equal(state.Name.FirstName) ||
			!plan.Name.LastName.Equal(state.Name.LastName) ||
			!plan.Name.Initials.Equal(state.Name.Initials) ||
			!plan.Name.Prefix.Equal(state.Name.Prefix)

		if nameChanged {
			updateReq.Name = &customers.Name{
				FirstName: plan.Name.FirstName.ValueString(),
				LastName:  plan.Name.LastName.ValueString(),
			}
			if !plan.Name.Initials.IsNull() {
				updateReq.Name.Initials = plan.Name.Initials.ValueString()
			}
			if !plan.Name.Prefix.IsNull() {
				updateReq.Name.Prefix = plan.Name.Prefix.ValueString()
			}
		}
	}

	// Send update
	err := customers.Update(r.client, handle, updateReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Updating Customer",
			fmt.Sprintf("Could not update customer %s: %s", handle, err.Error()),
		)
		return
	}

	// Call Read to refresh the state
	var readReq resource.ReadRequest
	readReq.State = resp.State
	var readResp resource.ReadResponse
	readResp.State = resp.State
	r.Read(ctx, readReq, &readResp)
	resp.State = readResp.State
	resp.Diagnostics.Append(readResp.Diagnostics...)
}

// Delete deletes the resource and removes the Terraform state on success.
func (r *CustomerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state CustomerModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	handle := state.Handle.ValueString()

	// Delete the customer
	err := customers.Delete(r.client, handle)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Deleting Customer",
			fmt.Sprintf("Could not delete customer %s: %s", handle, err.Error()),
		)
		return
	}
}

// ImportState imports an existing resource into Terraform.
func (r *CustomerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// The import ID is the customer handle
	handle := req.ID

	// Set both id and handle to the import ID
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), handle)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("handle"), handle)...)
}
